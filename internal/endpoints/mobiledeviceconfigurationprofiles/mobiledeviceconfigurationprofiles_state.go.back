// mobiledeviceconfigurationprofiles_state.go
package mobiledeviceconfigurationprofiles

import (
	"github.com/deploymenttheory/go-api-sdk-jamfpro/sdk/jamfpro"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

// updateTerraformState updates the Terraform state with the latest ResourceMobileDeviceConfigurationProfile
// information from the Jamf Pro API.
func updateTerraformState(d *schema.ResourceData, resource *jamfpro.ResourceMobileDeviceConfigurationProfile) diag.Diagnostics {
	var diags diag.Diagnostics

	// Create a map to hold the resource data
	resourceData := map[string]interface{}{
		"name":              resource.General.Name,
		"description":       resource.General.Description,
		"uuid":              resource.General.UUID,
		"deployment_method": resource.General.DeploymentMethod,

		//"redeploy_on_update":                resource.General.RedeployOnUpdate,
		//"redeploy_days_before_cert_expires": resource.General.RedeployDaysBeforeCertExpires,

		// Skipping stating payloads and let terraform handle it directly
		// "payloads": html.UnescapeString(resource.General.Payloads),
	}

	// Check if the level is "System" and set it to "Device Level", otherwise use the value from resource
	levelValue := resource.General.Level
	if levelValue == "System" {
		levelValue = "Device Level"
	}
	resourceData["level"] = levelValue

	// Set the 'site' attribute in the state only if it's not empty (i.e., not default values)
	site := []interface{}{}
	if resource.General.Site.ID != -1 {
		site = append(site, map[string]interface{}{
			"id": resource.General.Site.ID,
		})
	}
	if len(site) > 0 {
		if err := d.Set("site", site); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	// Set the 'category' attribute in the state only if it's not empty (i.e., not default values)
	category := []interface{}{}
	if resource.General.Category.ID != -1 {
		category = append(category, map[string]interface{}{
			"id": resource.General.Category.ID,
		})
	}
	if len(category) > 0 {
		if err := d.Set("category", category); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	// Initialize scope data
	scope := make(map[string]interface{})
	scope["all_mobile_devices"] = resource.Scope.AllMobileDevices
	scope["all_jss_users"] = resource.Scope.AllJSSUsers

	// Helper function calls to populate the scope data
	if tempDiags := setMobileDevices(d, "scope.0.mobile_devices", resource.Scope.MobileDevices); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	if tempDiags := setResourceScopeEntity(d, "scope.0.mobile_device_groups", resource.Scope.MobileDeviceGroups); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	if tempDiags := setResourceScopeEntity(d, "scope.0.jss_users", resource.Scope.JSSUsers); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	if tempDiags := setResourceScopeEntity(d, "scope.0.jss_user_groups", resource.Scope.JSSUserGroups); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	if tempDiags := setResourceScopeEntity(d, "scope.0.buildings", resource.Scope.Buildings); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	if tempDiags := setResourceScopeEntity(d, "scope.0.departments", resource.Scope.Departments); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}
	// Set scope limitations with the appropriate helper functions
	limitations := make(map[string]interface{})

	// Handle network segments limitations
	if tempDiags := setNetworkSegments(d, "scope.0.limitations.network_segments", resource.Scope.Limitations.NetworkSegments); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle users limitations
	if tempDiags := setResourceScopeEntity(d, "scope.0.limitations.users", resource.Scope.Limitations.Users); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle user groups limitations
	if tempDiags := setResourceScopeEntity(d, "scope.0.limitations.user_groups", resource.Scope.Limitations.UserGroups); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle iBeacons limitations
	if tempDiags := setResourceScopeEntity(d, "scope.0.limitations.ibeacons", resource.Scope.Limitations.Ibeacons); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Set the limitations map if needed
	if len(limitations) > 0 {
		if err := d.Set("scope.0.limitations", limitations); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	// Set scope exclusions with the appropriate helper functions
	exclusions := make(map[string]interface{})

	// Handle mobile devices exclusions
	if tempDiags := setMobileDevices(d, "scope.0.exclusions.mobile_devices", resource.Scope.Exclusions.MobileDevices); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle mobile device groups exclusions
	if tempDiags := setResourceScopeEntity(d, "scope.0.exclusions.mobile_device_groups", resource.Scope.Exclusions.MobileDeviceGroups); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle users exclusions
	if tempDiags := setResourceScopeEntity(d, "scope.0.exclusions.users", resource.Scope.Exclusions.Users); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle user groups exclusions
	if tempDiags := setResourceScopeEntity(d, "scope.0.exclusions.user_groups", resource.Scope.Exclusions.UserGroups); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle buildings exclusions
	if tempDiags := setResourceScopeEntity(d, "scope.0.exclusions.buildings", resource.Scope.Exclusions.Buildings); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle departments exclusions
	if tempDiags := setResourceScopeEntity(d, "scope.0.exclusions.departments", resource.Scope.Exclusions.Departments); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle network segments exclusions
	if tempDiags := setNetworkSegments(d, "scope.0.exclusions.network_segments", resource.Scope.Exclusions.NetworkSegments); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle JSS users exclusions
	if tempDiags := setResourceScopeEntity(d, "scope.0.exclusions.jss_users", resource.Scope.Exclusions.JSSUsers); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle JSS user groups exclusions
	if tempDiags := setResourceScopeEntity(d, "scope.0.exclusions.jss_user_groups", resource.Scope.Exclusions.JSSUserGroups); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Handle iBeacons exclusions
	if tempDiags := setResourceScopeEntity(d, "scope.0.exclusions.ibeacons", resource.Scope.Exclusions.IBeacons); len(tempDiags) > 0 {
		diags = append(diags, tempDiags...)
	}

	// Set the exclusions map if needed
	if len(exclusions) > 0 {
		if err := d.Set("scope.0.exclusions", exclusions); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	// Set the scope data with any appended limitations and exclusions at the end of all processing
	if len(scope) > 0 {
		if err := d.Set("scope", []interface{}{scope}); err != nil {
			diags = append(diags, diag.FromErr(err)...)
		}
	}

	return diags

}

// gatherMobileDevices converts a slice of MobileDevice entities to a format suitable for Terraform state.
func gatherMobileDevices(devices []jamfpro.MobileDeviceConfigurationProfileSubsetMobileDevice) ([]interface{}, error) {
	var deviceList []interface{}
	for _, device := range devices {
		deviceMap := map[string]interface{}{
			"id":               device.ID,
			"name":             device.Name,
			"udid":             device.UDID,
			"wifi_mac_address": device.WifiMacAddress,
		}
		deviceList = append(deviceList, deviceMap)
	}
	return deviceList, nil
}

// gatherScopeEntities converts a slice of general scope entities (like user groups, buildings) to a format suitable for Terraform state.
func gatherScopeEntities(entities []jamfpro.MobileDeviceConfigurationProfileSubsetScopeEntity) ([]interface{}, error) {
	var entityList []interface{}
	for _, entity := range entities {
		entityMap := map[string]interface{}{
			"id":   entity.ID,
			"name": entity.Name,
		}
		entityList = append(entityList, entityMap)
	}
	return entityList, nil
}

// Helper function specific to network segments if they have an additional field such as 'uid'.
func gatherNetworkSegments(segments []jamfpro.MobileDeviceConfigurationProfileSubsetNetworkSegment) ([]interface{}, error) {
	var segmentList []interface{}
	for _, segment := range segments {
		segmentMap := map[string]interface{}{
			"id":   segment.ID,
			"name": segment.Name,
			"uid":  segment.UID,
		}
		segmentList = append(segmentList, segmentMap)
	}
	return segmentList, nil
}

// // setResourceScopeEntity is a helper function to set lists of maps in Terraform state.
// func setResourceScopeEntity(d *schema.ResourceData, key string, items []jamfpro.MobileDeviceConfigurationProfileSubsetScopeEntity) diag.Diagnostics {
// 	var diags diag.Diagnostics
// 	list := make([]interface{}, len(items))

// 	for i, item := range items {
// 		mapItem := map[string]interface{}{
// 			"id":   item.ID,
// 			"name": item.Name,
// 		}
// 		list[i] = mapItem
// 	}

// 	if err := d.Set(key, list); err != nil {
// 		diags = append(diags, diag.FromErr(err)...)
// 	}
// 	return diags
// }

// // Additional helper function for network segments due to the 'UID' field
// func setNetworkSegments(d *schema.ResourceData, key string, segments []jamfpro.MobileDeviceConfigurationProfileSubsetNetworkSegment) diag.Diagnostics {
// 	var diags diag.Diagnostics
// 	list := make([]interface{}, len(segments))

// 	for i, segment := range segments {
// 		mapItem := map[string]interface{}{
// 			"id":   segment.ID,
// 			"name": segment.Name,
// 			"uid":  segment.UID,
// 		}
// 		list[i] = mapItem
// 	}

// 	if err := d.Set(key, list); err != nil {
// 		diags = append(diags, diag.FromErr(err)...)
// 	}
// 	return diags
// }

// // setMobileDevices is a helper function to set lists of mobile devices in Terraform state.
// func setMobileDevices(d *schema.ResourceData, key string, devices []jamfpro.MobileDeviceConfigurationProfileSubsetMobileDevice) diag.Diagnostics {
// 	var diags diag.Diagnostics
// 	list := make([]interface{}, len(devices))

// 	for i, device := range devices {
// 		mapDevice := map[string]interface{}{
// 			"id":               device.ID,
// 			"name":             device.Name,
// 			"udid":             device.UDID,
// 			"wifi_mac_address": device.WifiMacAddress,
// 		}
// 		list[i] = mapDevice
// 	}

// 	if err := d.Set(key, list); err != nil {
// 		diags = append(diags, diag.FromErr(err)...)
// 	}
// 	return diags
// }
